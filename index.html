import SwiftUI
import SwiftData
import Combine
import FSCalendar
import PhotosUI
import UserNotifications

// MARK: - [1. Design System]
extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        self.init(.sRGB, red: Double(int >> 16)/255, green: Double(int >> 8 & 0xFF)/255, blue: Double(int & 0xFF)/255, opacity: 1)
    }
    static let ddbBg = Color(hex: "F7F4EB")
    static let ddbMain = Color(hex: "8D6E63")
    static let ddbAccent = Color(hex: "5D4037")
}

struct DDBCardModifier: ViewModifier {
    func body(content: Content) -> some View {
        content
            .padding(20)
            .background(Color.white)
            .cornerRadius(24)
            .shadow(color: .black.opacity(0.05), radius: 10, x: 0, y: 5)
    }
}

extension View {
    func ddbCard() -> some View { self.modifier(DDBCardModifier()) }
    func hideKeyboard() { UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil) }
}

// MARK: - [2. Models & Settings]
@Model final class LetterModel {
    var id: UUID = UUID(); var date: Date = Date(); var deliveryDate: Date = Date()
    var content: String; var reply: String = ""; var stampName: String = ""; var isWaitingReply: Bool = true
    var sleepTime: Double; var mood: String; var condition: String; var weather: String; var exercise: String
    var attachedImageData: Data?
    
    init(content: String, delay: Int, sleep: Double, mood: String, condition: String, weather: String, exercise: String, imageData: Data?) {
        self.content = content; self.sleepTime = sleep; self.mood = mood; self.condition = condition; self.weather = weather; self.exercise = exercise; self.attachedImageData = imageData
        self.deliveryDate = Calendar.current.date(byAdding: .minute, value: delay, to: Date()) ?? Date()
    }
}

@Model final class TrackerModel {
    var id: UUID = UUID(); var date: Date = Date()
    var sleepTime: Double; var mood: String; var condition: String; var weather: String; var exercise: String
    init(sleep: Double, mood: String, condition: String, weather: String, exercise: String) {
        self.sleepTime = sleep; self.mood = mood; self.condition = condition; self.weather = weather; self.exercise = exercise
    }
}

@Model final class FortuneModel {
    var id: UUID = UUID(); var date: Date = Date(); var content: String
    init(content: String) { self.content = content }
}

final class AppSettings: ObservableObject {
    static let shared = AppSettings()
    @AppStorage("userName") var userName = "ë‚˜ì˜ ì´ë¦„"
    @AppStorage("characterName") var characterName = "íˆìš”ë¦¬"
    @AppStorage("openAIKey") var openAIKey = ""
    @AppStorage("hasSeenGuide") var hasSeenGuide = false
    @AppStorage("personaPrompt") var personaPrompt = ""
    @Published var isSetupCompleted: Bool = false
    
    init() { if !openAIKey.isEmpty { isSetupCompleted = true } }
    func completeSetup() { if !openAIKey.isEmpty { withAnimation { isSetupCompleted = true } } }
}

// MARK: - [3. Main Views]
struct ContentView: View {
    @StateObject var settings = AppSettings.shared
    @State private var refreshID = UUID()
    @State private var showGuide = false
    
    var body: some View {
        ZStack {
            if !settings.isSetupCompleted { SettingsView() }
            else {
                TabView {
                    DashboardView(refreshID: refreshID).tabItem { Label("ì˜¤ëŠ˜", systemImage: "house.fill") }
                    TrackerWriteView().tabItem { Label("ê¸°ë¡", systemImage: "clipboard.fill") }
                    LetterWriteView(refreshID: $refreshID).tabItem { Label("í¸ì§€", systemImage: "envelope.fill") }
                    LetterCalendarView(refreshID: refreshID).tabItem { Label("ìº˜ë¦°ë”", systemImage: "calendar") }
                    FortuneView().tabItem { Label("ìš´ì„¸", systemImage: "sparkles") }
                    SettingsView().tabItem { Label("ì„¤ì •", systemImage: "gearshape.fill") }
                }
                .accentColor(.ddbMain)
            }
            if showGuide { GuidePopupView(isPresented: $showGuide) }
        }
        .onAppear { if settings.isSetupCompleted && !settings.hasSeenGuide { withAnimation { showGuide = true } } }
    }
}

// MARK: - [4. Dashboard & Logic]
struct DashboardView: View {
    var refreshID: UUID
    @Query(sort: \LetterModel.date, order: .reverse) var letters: [LetterModel]
    @Query(sort: \TrackerModel.date, order: .reverse) var trackers: [TrackerModel]
    @State private var adviceText = "ë°˜ê°€ì›Œìš”! ì˜¤ëŠ˜ ê¸°ë¶„ì€ ì–´ë–¤ê°€ìš”? âœ¨"
    
    var todayLetter: LetterModel? { letters.first(where: { Calendar.current.isDateInToday($0.date) }) }
    var todayTracker: TrackerModel? { trackers.first(where: { Calendar.current.isDateInToday($0.date) }) }

    var body: some View {
        NavigationStack {
            ZStack {
                Color.ddbBg.ignoresSafeArea()
                ScrollView {
                    VStack(spacing: 20) {
                        // ìºë¦­í„° ë§í’ì„  ìš”ì•½
                        HStack(spacing: 15) {
                            Circle().fill(Color.ddbMain.opacity(0.1)).frame(width: 60, height: 60).overlay(Image(systemName: "person.fill").foregroundColor(.ddbMain))
                            VStack(alignment: .leading) {
                                Text(AppSettings.shared.characterName).bold()
                                Text(todayLetter?.isWaitingReply == true ? "í¸ì§€ë¥¼ ì“°ê³  ìˆì–´ìš”... ğŸ•°ï¸" : (todayLetter?.reply ?? "ì˜¤ëŠ˜ë„ ì¢‹ì€ í•˜ë£¨ ë³´ë‚´ì„¸ìš”!")).font(.subheadline).lineLimit(2)
                            }
                            Spacer()
                        }.ddbCard()
                        
                        // ê±´ê°• ê¸°ë¡ ìš”ì•½ (ìŠ¤í¬ë¦°ìƒ· ë°˜ì˜)
                        VStack(alignment: .leading, spacing: 12) {
                            Label("ì˜¤ëŠ˜ì˜ ê±´ê°• ê¸°ë¡", systemImage: "heart.text.square.fill").font(.headline)
                            if let tracker = todayTracker {
                                Grid(alignment: .leading, horizontalSpacing: 20, verticalSpacing: 10) {
                                    GridRow { Text("ğŸ˜Š ê¸°ë¶„: \(tracker.mood)"); Text("ğŸ¤’ ì»¨ë””ì…˜: \(tracker.condition)") }
                                    GridRow { Text("ğŸƒ ìš´ë™: \(tracker.exercise)"); Text("â˜€ï¸ ë‚ ì”¨: \(tracker.weather)") }
                                }
                            } else {
                                Text("ê¸°ë¡ íƒ­ì—ì„œ ì˜¤ëŠ˜ì„ ê¸°ë¡í•´ì£¼ì„¸ìš”.").font(.caption).foregroundColor(.gray)
                            }
                        }.ddbCard()
                    }.padding()
                }
            }
            .navigationTitle("DIRI-Penpal")
        }
    }
}

// MARK: - [5. Tracker & History (ë„¤ë¹„ê²Œì´ì…˜ í•´ê²°)]
struct TrackerWriteView: View {
    @Environment(\.modelContext) private var modelContext
    @State private var sleepTime: Double = 7.0
    @State private var mood = "ë³´í†µ"
    @State private var isSaved = false

    var body: some View {
        NavigationStack {
            ZStack {
                Color.ddbBg.ignoresSafeArea()
                VStack(spacing: 25) {
                    VStack(spacing: 20) {
                        HStack { Text("ğŸŒ™ ìˆ˜ë©´ ì‹œê°„"); Spacer(); Text("\(String(format: "%.1f", sleepTime))h").bold() }
                        Slider(value: $sleepTime, in: 0...12, step: 0.5).tint(.ddbMain)
                        Picker("ê¸°ë¶„", selection: $mood) {
                            ForEach(["ì¢‹ìŒ", "ë³´í†µ", "ìš°ìš¸"], id: \.self) { Text($0) }
                        }.pickerStyle(.segmented)
                    }.ddbCard()
                    
                    Button {
                        modelContext.insert(TrackerModel(sleep: sleepTime, mood: mood, condition: "ë³´í†µ", weather: "ë§‘ìŒ", exercise: "ì•ˆí•¨"))
                        withAnimation { isSaved = true }
                    } label: {
                        Text(isSaved ? "ì €ì¥ ì™„ë£Œ!" : "ê¸°ë¡ ì €ì¥í•˜ê¸°").bold().frame(maxWidth: .infinity).padding().background(isSaved ? .green : Color.ddbMain).foregroundColor(.white).cornerRadius(15)
                    }
                    
                    NavigationLink(destination: TrackerHistoryView()) {
                        Label("ì§€ë‚œ ê¸°ë¡ ë‹¬ë ¥ìœ¼ë¡œ ë³´ê¸°", systemImage: "calendar").bold().frame(maxWidth: .infinity).padding().background(.white).foregroundColor(.ddbMain).cornerRadius(15).shadow(radius: 2)
                    }
                    Spacer()
                }.padding()
            }
            .navigationTitle("ì˜¤ëŠ˜ì˜ ê¸°ë¡")
        }
    }
}

// MARK: - [6. FSCalendar & Custom Rendering (ê²¹ì¹¨ ë°©ì§€)]
class OutlinedLabel: UILabel {
    var outlineColor: UIColor = .white
    var outlineWidth: CGFloat = 3.0
    override func drawText(in rect: CGRect) {
        let c = UIGraphicsGetCurrentContext()
        c?.setLineWidth(outlineWidth); c?.setTextDrawingMode(.stroke)
        let tc = self.textColor; self.textColor = outlineColor; super.drawText(in: rect)
        c?.setTextDrawingMode(.fill); self.textColor = tc; super.drawText(in: rect)
    }
}

struct FSCalendarWrapper: UIViewRepresentable {
    @Binding var selectedDate: Date; let letters: [LetterModel]
    func makeUIView(context: Context) -> FSCalendar {
        let c = FSCalendar()
        c.delegate = context.coordinator; c.dataSource = context.coordinator
        c.appearance.titleDefaultColor = .clear; c.appearance.titlePlaceholderColor = .clear
        c.appearance.todayColor = .clear; c.appearance.selectionColor = .clear
        return c
    }
    func updateUIView(_ uiView: FSCalendar, context: Context) { uiView.reloadData() }
    func makeCoordinator() -> Coordinator { Coordinator(self) }
    
    class Coordinator: NSObject, FSCalendarDelegate, FSCalendarDataSource {
        var parent: FSCalendarWrapper; init(_ parent: FSCalendarWrapper) { self.parent = parent }
        func calendar(_ calendar: FSCalendar, didSelect date: Date, at monthPosition: FSCalendarMonthPosition) { parent.selectedDate = date; calendar.reloadData() }
        func calendar(_ calendar: FSCalendar, willDisplay cell: FSCalendarCell, for date: Date, at monthPosition: FSCalendarMonthPosition) {
            cell.subviews.filter{$0.tag==555}.forEach{$0.removeFromSuperview()}
            let base = UIView(frame: cell.bounds.insetBy(dx: 2, dy: 2)); base.tag=555; base.layer.cornerRadius=8; base.clipsToBounds=true
            
            if Calendar.current.isDate(date, inSameDayAs: parent.selectedDate) {
                base.layer.borderWidth = 2; base.layer.borderColor = UIColor(Color.ddbMain).cgColor
            }
            
            let letter = parent.letters.first { Calendar.current.isDate($0.date, inSameDayAs: date) }
            if let stamp = letter?.stampName, let img = UIImage(named: stamp) {
                let iv = UIImageView(image: img); iv.contentMode = .scaleAspectFill; iv.frame = base.bounds; base.addSubview(iv)
            }
            
            let l = OutlinedLabel(frame: base.bounds); l.text = "\(Calendar.current.component(.day, from: date))"
            l.textAlignment = .center; l.font = .boldSystemFont(ofSize: 14); l.textColor = .black; l.outlineColor = .white; l.outlineWidth = 3
            base.addSubview(l); cell.insertSubview(base, at: 0)
        }
    }
}

// MARK: - [7. OpenAI Helper]
func fetchOpenAI(system: String, context: String, user: String, imageData: Data?) async -> String {
    guard let url = URL(string: "https://api.openai.com/v1/chat/completions") else { return "URL ì˜¤ë¥˜" }
    var req = URLRequest(url: url); req.httpMethod = "POST"
    req.setValue("Bearer \(AppSettings.shared.openAIKey)", forHTTPHeaderField: "Authorization")
    req.setValue("application/json", forHTTPHeaderField: "Content-Type")
    
    let messages: [[String: Any]] = [["role": "system", "content": system], ["role": "user", "content": user]]
    let body: [String: Any] = ["model": "gpt-4o", "messages": messages, "max_tokens": 1000]
    req.httpBody = try? JSONSerialization.data(withJSONObject: body)
    
    if let (data, _) = try? await URLSession.shared.data(for: req),
       let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
       let choices = json["choices"] as? [[String: Any]],
       let content = (choices.first?["message"] as? [String: Any])?["content"] as? String {
        return content
    }
    return "í†µì‹  ì‹¤íŒ¨... API í‚¤ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
}

// ë‚˜ë¨¸ì§€ ë·°ë“¤(FortuneView, TrackerHistoryView ë“±)ì€ ì œê³µí•´ì£¼ì‹  ë¡œì§ê³¼ ë™ì¼í•˜ê²Œ ì‘ë™í•˜ë©°, 
// NavigationStack ë‚´ì—ì„œ ì•ˆì „í•˜ê²Œ êµ¬ë™ë©ë‹ˆë‹¤.
